{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This website is an attempt to start blogging and to practice <code>technical writing</code>. It will contain my thoughts, ideas and visions (and maybe some guides?).</p> <p>Side Note</p> <p>Expect random thoughts on just about anything under this sky and sometimes beyond.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/04/05/bit-by-bit/","title":"bit by bit","text":"<p>This post is meant to be a dissection of a small piece of code I wrote recently. It\u2019s a preventive measure taken to preserve the sanity of the person(me) trying to understand the code after 6 months.</p> <p>I will not bore you with the project details. The gist is, a parent board tells the child board(my firmware) to scan a particular number of channels. Now machines, being machines convey this through bitmaps. Each bit of the bitmap represents one out of 64 channels. What it is trying to say is, scan only the channels for which the bit is set to <code>1</code>.</p> <p>So my firmware needs to parse this bitmap and identify the channels that are selected.</p> <p>The naive solution for this would be to go through each bit using a for-loop \u2013 check if the bit is set \u2013 scan if set.</p> <pre><code>  for (int i = 0; i &lt; 64; i++) {\n        if (bitmap &amp; (1ULL &lt;&lt; i)) { // Check if the ith bit is set\n            startScan(i+1);\n        }\n    }\n</code></pre> <p>By the time I wrote this I realized that I\u2019m doing the unnecessary work of going through all the bits when I could go through just the bits that are set. And I knew an algorithm just for that.</p>"},{"location":"blog/2025/04/05/bit-by-bit/#brian-kernighans-method","title":"Brian Kernighan\u2019s method","text":"<p>Brian Kernighan, a great computer scientist once mentioned in one of his books(which happens to be the first ever book on C Language) that in a two\u2019s complement number system, x = x &amp; (x-1) deletes the rightmost 1-bit in x. (where \u2018&amp;\u2019 is bitwise AND operator in C). See a 1-byte example below.</p> <p></p> <p>(Initial parts of this post is meant to warm up your brain to handle all the bit twiddling that follows. So you might see me over-explaining some rather simple topics)</p> <p>See how only the rightmost bit is reset. If I continue this process recursively on the result - at the end - all the set bits will be deleted, making the number <code>00000000</code>. This algorithm reduces the number of iterations to the number of bits set in the number, giving this algorithm a Time complexity of <code>O(k)</code> where <code>k</code> is the number of bits set in the number.</p> <p>My idea \u2013 Use this algorithm to repeatedly delete the last set bit, starting the channel scan for that last set bit during each iteration!</p> <pre><code>while(bitmap !=0)\n{\n    //Find index of the last set bit and start scan.\n    bitmap = bitmap &amp; (bitmap-1);\n}\n</code></pre> <p>Now the task that was left was to find the index of the last set bit. We need to change gears here \u2013 the post is going to get more complicated as we progress.</p> <p>If we have a number with just one bit set, the index of that bit would be equal to log2 of that number. Don\u2019t believe me? Check the image below.</p> <p></p> <p>Yes, single-1 numbers are powers of 2, of course you knew this already. Now, get ready for a magic trick</p> <pre><code>(x &amp; -x) gives x with only the last bit set.\n</code></pre> <p>If you\u2019re unfamiliar with two\u2019s complement, this expression might seem like a magic trick. But once you understand how negative numbers are represented in binary, it becomes intuitive.</p>"},{"location":"blog/2025/04/05/bit-by-bit/#twos-complement-representation","title":"Two's complement Representation","text":"<p>In an n-bit system, the negative representation of a number <code>x</code> is obtained by subtracting it from <code>2\u207f</code>:</p> <pre><code>-x = 2\u207f - x\n</code></pre>"},{"location":"blog/2025/04/05/bit-by-bit/#how-is-this-done-in-practice","title":"How Is This Done in Practice?","text":"<p>This is done in two steps:</p> <ol> <li> <p>Bitwise NOT (<code>~x</code>)    Inverts all bits (equivalent to subtracting from <code>2\u207f - 1</code>).</p> </li> <li> <p>Add 1    Completes the subtraction from <code>2\u207f</code>.</p> </li> </ol>"},{"location":"blog/2025/04/05/bit-by-bit/#the-trick-behind-x-x","title":"The Trick Behind <code>x &amp; -x</code>","text":"<p>Applying <code>x &amp; -x</code> isolates the last set bit. Here's why:</p> <ul> <li><code>-x</code> has all the same bits as <code>~x + 1</code>.</li> <li>All trailing zeros in <code>x</code> turn into ones in <code>-x</code>.</li> <li>Adding <code>1</code> makes them zero again while flipping the first nonzero bit to <code>1</code>.</li> </ul> <p>So, when <code>x</code> and <code>-x</code> are ANDed together, only this single bit remains set.</p> <p>Tip: If this explanation went over your head, try writing it down in binary and working through the steps\u2014it\u2019ll click!</p>"},{"location":"blog/2025/04/05/bit-by-bit/#getting-the-bit-position","title":"Getting the Bit Position","text":"<p>Now that we've isolated the only set bit, we can just perform a <code>log\u2082()</code> operation on the result to get the bit position.</p> <p>But of course, we're not stopping there\u2014we\u2019re not importing the whole <code>math</code> library just to perform <code>log\u2082()</code>!</p>"},{"location":"blog/2025/04/05/bit-by-bit/#hashing","title":"Hashing","text":"<p>For an n-bit number, there will be n different numbers with only one bit set. Hence, we can rely on the good old-fashioned hashing algorithm to map the n different numbers to an n-sized lookup table (also called a hashmap).</p> <p>Then, given a number <code>x</code> with only one bit set, we can look up <code>h(x)</code> in the hash table where the index of the set bit will be stored!</p> <p>We are essentially creating our own optimized log\u2082 function for n-bit numbers.</p>"},{"location":"blog/2025/04/05/bit-by-bit/#for-this-strategy-to-work-efficiently-however-we-need","title":"For this strategy to work efficiently, however, we need:","text":"<ul> <li>The hash table to be small,  </li> <li>The hash function to be easily computable, and  </li> <li>The hash function to produce no collisions, i.e., no two single-1 words <code>x</code> and <code>y</code> should produce hash values such that <code>h(x) = h(y)</code>.</li> </ul> <p>Using deBruijn sequences satisfies all three criteria!</p> <p>So what exactly is this deBruijn?</p>"},{"location":"blog/2025/04/05/bit-by-bit/#debruijn-sequences","title":"deBruijn Sequences","text":"<p>If you are into competitive programming deBruijn sequences might not be new to you. A binary deBruijn sequence of length <code>n</code>, where <code>n</code> is a power of 2, is a cyclic binary sequence of <code>n</code> bits in which every possible <code>log\u2082(n)</code>-bit binary string appears exactly once as a contiguous substring.</p> <p>For example, consider a deBruijn sequence of length 8: <code>00011101</code>. Every possible 3-bit binary sequence appears exactly once when viewed through a sliding window of 3 bits, moving one position at a time:</p> <pre><code>000  \n001  \n011  \n111  \n110  \n101  \n010 (wrapping around)  \n100 (wrapping around)\n</code></pre> <p>The <code>n</code> single-1 numbers can be mapped to the <code>n</code> positions in the hash map by just multiplying the number with the deBruijn sequence and extracting <code>log\u2082(n)</code> leading bits. Multiplying the deBruijn sequence with the <code>n</code> numbers would make sure that the first <code>log\u2082(n)</code> bits will be a different 0-1 sequence for each number!</p> <pre><code>h(x) = (x * deBruijn) &gt;&gt; (n - log\u2082(n))\n</code></pre> <p>I know that this is a lot but you can take a break here and try to figure out how this works out.</p>"},{"location":"blog/2025/04/05/bit-by-bit/#explanation","title":"Explanation","text":"<p>Another way that I like to look at deBruijn sequence is this \u2013 the first three MSB bits (counting from left) will give a different sequence for every left shift performed. Check the image below.</p> <p></p> <p>We established earlier that if the number has only one bit set, the number is a power of 2. And multiplying any number by a power of 2 is basically left shifting the number by the power!</p> <p>If you are a seasoned firmware developer, you would know that all compilers optimize multiplication operations that involve powers of 2 into shift operations, since a shift operation is a register operation and can be done in a single CPU cycle.</p> <p>Therefore, multiplying the number with the deBruijn sequence essentially gives us the left-shifted version of the sequence, which in turn gives different 0-1 sequences in the first <code>log\u2082(n)</code> bits. It took me some time to wrap my head around this as well.</p> <p>In <code>h(x) = (x * deBruijn) &gt;&gt; (n - log\u2082(n))</code> , <code>(x * deBruijn)</code> gives the shifted sequence and <code>&gt;&gt; (n - log\u2082(n))</code> isolates the first three bits.</p> <p>This will be the hashmap for the example mentioned above (length 8 bits):</p> <pre><code>h(x)    index\n000     0\n001     1\n010     6\n011     2\n100     7\n101     5\n110     4\n111     3\n</code></pre> <p>\ud83d\udca1 For more clarity: <code>index</code> will be the number of left shifts (power of the number) required to get the particular <code>h(x)</code> sequence.</p>"},{"location":"blog/2025/04/05/bit-by-bit/#64-bit-equivalent-solution-using-de-bruijn-sequence","title":"64-bit Equivalent Solution Using de\u202fBruijn Sequence","text":"<pre><code>// De Bruijn sequence lookup table for 64-bit numbers\nstatic const int de_bruijn_index[64] = {\n     0,  1, 48,  2, 57, 49, 28,  3,\n    61, 58, 50, 42, 38, 29, 17,  4,\n    62, 55, 59, 36, 53, 51, 43, 22,\n    45, 39, 33, 30, 24, 18, 12,  5,\n    63, 47, 56, 27, 60, 41, 37, 16,\n    54, 35, 52, 21, 44, 32, 23, 11,\n    46, 26, 40, 15, 34, 20, 31, 10,\n    25, 14, 19,  9, 13,  8,  7,  6\n};\n\n// Function to find the last set bit's position (0-based)\nint last_set_bit_position(uint64_t x) {\n    if (x == 0) return -1; // No set bit\n\n    static const uint64_t de_bruijn = 0x03f79d71b4cb0a89ULL; // De Bruijn sequence\n    uint64_t isolated_bit = x &amp; -x;  // Isolate last set bit\n    return de_bruijn_index[(isolated_bit * de_bruijn) &gt;&gt; 58]; // Get position\n}\n</code></pre> <p>\ud83e\udde0 <code>0x03f79d71b4cb0a89ULL</code> is the de\u202fBruijn sequence for 64-bit numbers.</p> <p>This implementation uses the technique we discussed: - It isolates the last set bit (<code>x &amp; -x</code>), - Multiplies it with the de\u202fBruijn constant, - Shifts the result to extract a unique top 6-bit pattern (since <code>2\u2076 = 64</code>), - And uses it as an index into the precomputed lookup table to get the position.</p> <p>Bit manipulation is one of those topics that, once mastered, gives you a whole new perspective on problem-solving in embedded systems and low-level programming. From naive loops to Brian Kernighan\u2019s trick, and finally leveraging de Bruijn sequences, we\u2019ve explored multiple ways to efficiently extract set bit positions.</p> <p>While the de Bruijn method is an elegant software solution, modern compilers offer hardware-optimized built-ins like <code>__builtin_ffsl()</code>, making them the practical choice in real-world applications (I ended up using that).</p> <p><pre><code>while(bitmap !=0)\n{\n  int pos = __builtin_ffsl(bitmap);\n  startScan(pos);\n  bitmap = bitmap &amp; (bitmap-1); \n}\n</code></pre> The key takeaway? Understanding these optimizations helps you make informed decisions when writing performance-critical firmware.</p> <p>I hope this deep dive into bit twiddling was as fun for you as it was for me! Until next time\u2014happy coding, and may your bits always be set exactly where you need them.</p>"},{"location":"blog/2024/01/25/components-has-arrived/","title":"Components has arrived!","text":"<p>Finally I have everything to start working with. The components arrived earlier this week and this is how my desk looks now!</p> <p></p> <p>Started today with testing the LED strip. I used RMT examples provided by ESP-IDF itself to test out the leds. Did a bit of soldering- rough mostly because this is just the prototyping stage. I wasn't able to verify the proper working of the Rotary Encoder. I tried flashing an Arduino code I found online to the esp32 xiao board, but the rotary encoder wasn't giving proper output for it. I need to take it over to an oscilloscope to verify if the encoder is generating proper quadrature waveforms. </p> <p>Will integrate the firmware for led and encoder together in the coming week. I also have to decide if I should spend some time picking up CPP. Because, almost all Matter examples provided in the ESP-Matter SDK are written in CPP. Since I have a bit of background in python and Java, picking up CPP wouldn't be that hard. I had found this YT playlist, but I don't know if it's worth the time</p>"},{"location":"blog/2024/11/11/always-use-brackets-with-your-define-expressions/","title":"Always Use Brackets with Your <code>#define</code> Expressions!","text":"<p>Recently, I discovered the actual working of <code>#define</code>. When you use <code>#define</code> for expressions, it doesn\u2019t evaluate or compile the expression at that point; it simply copies the expression wherever it appears in the code during the pre-processing stage.</p> <p>Check out the example below to see why this can be an issue:</p> <pre><code>#define ONE_BYTE 1\n#define TYPE ONE_BYTE\n#define ID ONE_BYTE\n#define HEADER_LENGTH TYPE + ID\n\nuint8_t calcPayloadLength(uint8_t total_length) {\n    uint8_t payload_length = total_length - HEADER_LENGTH;\n    return payload_length;\n}\n</code></pre> <p>If you didn\u2019t catch it, here\u2019s what happens: since the value is copied directly, <code>HEADER_LENGTH</code> will be replaced by <code>1 + 1</code>. The expression becomes <code>total_length - 1 + 1</code>, which is not what we expected. Wrapping the <code>#define</code> expression in parentheses would fix this.</p> <p>For some reason, I assumed that, because I was defining constants, the compiler would optimize it and replace <code>HEADER_LENGTH</code> with <code>2</code> instead of <code>1 + 1</code>. I tried different optimization levels and realized that optimization doesn\u2019t affect the pre-processing stage.</p> <p>I have to admit, it took me about an hour to pinpoint this bug in my code! The issue surfaced only after I switched from hard-coded numbers to macros, as my linter suggested.</p> <p>So, always remember: use braces with <code>#define</code> expressions!</p>"},{"location":"blog/2024/01/22/first-blog/","title":"First Blog","text":"<p>It's 25 minutes past 1:00 AM. I have office in the morning. I don't know why, but I am motivated to set up this website before going to sleep!</p> <p>Ordered few components for my next project. It might reach tomorrow/ day after!</p> <p>Hopefully</p>"},{"location":"blog/2024/01/22/hosting-the-page/","title":"Hosting the page!","text":"<p>Initial setup of the page has been done. This will be the last blog before I host this website! Pretty excited!</p>"},{"location":"blog/2024/12/16/finally-set-up-a-home-server/","title":"Finally Set up a home server","text":"<p>I got me hands on a slick Ti Processor EVM - the SK-AM62x EVM. I spend this weekend tinkering around with it and set up a home server (finally!).</p>"},{"location":"blog/2024/12/16/finally-set-up-a-home-server/#ti-am62x-evm","title":"Ti AM62x EVM","text":"<p>After many weeks of waiting, I finally got my hands on this EVM. It houses the AM62 processor, which features a quad-core 64-bit ARM Cortex-A53 MPU and a single-core ARM Cortex-M4F MCU. This is my first time working with a processor after spending nearly two years working exclusively with MCUs (though I\u2019m not sure if the nRF5340 SoC counts as a processor). </p> <p>The Processor SDK provides pre-built images, and I chose the Debian Trixie image to run on it. I spent an entire night trying to boot the device from an SD card, only to realize the next day that the issue was caused by the software I used to flash the image\u2014BalenaEtcher. The problem seemed to be with the latest version of the software. Reverting to an older version did the trick, and I was finally able to get it running!  </p>"},{"location":"blog/2024/12/16/finally-set-up-a-home-server/#services","title":"Services","text":"<p>The EVM has only 2 GB of RAM, so setting up Jellyfin wasn\u2019t an option. However, I managed to set up Home Assistant, something I had been wanting to do for a long time. The setup process was pretty straightforward. I decided to run it as a Docker container instead of using the full Home Assistant OS. Additionally, I set up Portainer to manage the Docker containers running on my server. </p> <p>Since I had Home Assistant running, I decided to pair it with a smart light. So, I made one myself.  </p>"},{"location":"blog/2024/12/16/finally-set-up-a-home-server/#smart-light-box-ill-think-of-a-cooler-name-later","title":"Smart Light Box (I\u2019ll think of a cooler name later)","text":"<p>If you\u2019ve read my previous posts, you might know that I have many LED strips and rings lying around. I repurposed one of them to create a cute little glowing box. I used the standard WLED firmware to control the strips. It even has direct integration with Home Assistant, which made my life so much easier! </p>"},{"location":"blog/2024/12/16/finally-set-up-a-home-server/#ending-notes","title":"Ending Notes","text":"<p>Overall, it was a fun and productive weekend! For the past couple of months, I had been doing nothing but sleeping during the weekends. Also, I want to learn Astro so I can port this website to it. I love the concept of the command palette in VS Code and similar features in ARC, and I want to incorporate something like that into my website. Unfortunately, I couldn\u2019t find any implementation for it in MkDocs, so I decided to switch to Astro. Let\u2019s see\u2014hopefully, I\u2019ll sit down to learn it next weekend!  </p>"},{"location":"blog/2024/01/28/work-in-progress/","title":"Work in Progress","text":"<p>The project has reached its first milestone. As the saying goes, the first step is often the most challenging, and this was certainly the case here.</p>"},{"location":"blog/2024/01/28/work-in-progress/#setting-up-the-development-environment","title":"Setting up the Development Environment","text":"<p>The full setup of the SDK - ESP IDF and familiarizing with it really took me a few days. But now that I'm feeling comfortable with it, I can say this is far better than using the Arduino IDE for programming ESP chips. We literally have control over everything.</p> <p>I started off with prototyping code for the rotary encoder and the addressable LEDs. I got both working individually and somewhat together. The only problem is there is a huge latency between increasing the counter value and setting LED lights.</p> <p>My favorite part was developing the state machine for the Rotary Encoder. This state machine eliminates much of the noise generated between detents. The state machine is based on Mo-Thunderz's Rotary Encoder driver for Arduino, which was actually based on Oleg Mazurov's driver for Arduino. I took the gist of both and made my own.</p>"},{"location":"blog/2024/01/28/work-in-progress/#leds-are-so-fancy","title":"LEDs are so fancy!","text":"<p>LEDs are fascinating but confusing. I straight out copied the RMT-LED example provided by ESP-IDF, but soon I will learn what exactly this RMT peripheral does. Maybe by next week, I will have a low latency switch control going on, to which I can integrate the matter (or to the matter example, I would integrate this, heh).</p> <p></p>"},{"location":"blog/2024/01/28/work-in-progress/#blog-experience","title":"Blog Experience","text":"<p>Regarding the blog experience, it's been fun. I look forward to writing here. I might ask some of my friends to contribute here at times. Also might add an RSS feature so anyone reading this can stay updated, heh.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/blog/","title":"Blog","text":""},{"location":"blog/category/project-updates/","title":"Project Updates","text":""},{"location":"blog/category/matter/","title":"Matter","text":""}]}